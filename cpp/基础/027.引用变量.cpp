#include<iostream>
using namespace std;

int& test01() {
    static int a = 10;
    return a;
}

int main27(){
    //一.普通的引用变量
    int y = 1;    //定义一个普通变量y
    int& x = y;   //定义一个引用变量x,它是普通变量y的引用（即别名，x是y的别名）
    int* p = &y;   //定义一个指针变量p,指向普通变量y

    cout << "普通变量y的地址：" << &y << "    普通变量y的值：" << y << endl;
    cout << "引用变量x的地址：" << &x << "    引用变量x的值：" << x << endl;
    cout << "指针变量p的内容：" << p << "    指针变量p所指向变量的值：" << *p << endl;

    //x是引用类型，是普通变量的引用类型。
    //结合代码1，它引用的对象是普通变量y，C++中引用类型实际上就是一个别名
    //引用变量x并不是一个实际存在的独立的变量，它只是普通变量y的一个别名而已
    //所以引用变量x的地址和值与普通变量y的地址和值完全相同，地址均为0x6afee4，值均为1
    //（附：只有C++中有引用变量，C语言中没有）。
    //引用在定义时必须初始化
    //引用绑定后不可换绑。

    //二。指针类型引用：
    int* &x2 =   p;
    cout << "x2的内容是" << x2<<"     " << "x2指向的值是 " << *x2<<endl;
    cout << "指针p的地址是" << &p << "     x2的地址是 " << &x2 << endl;
    
    cout << "当对变化指针p时" << endl;
    *p = 10;
    cout << "此时  y= " << y << " *x2= " << *x2 << endl;
    cout << "当引用变量x2变化时：" << endl;
    *x2 = 20;
    cout << "此时 y= " << y << "  *p= " << *p << endl;
    //注意：指针类型的引用变量并不是指针，它只是一个别名或者说是指向指针的一个引用。
    //它本身并不保存内存地址，而是指向已经存在的指针变量的内存地址。
    //因此，对于指针类型的引用变量所做的任何改动都会直接反映在该指针变量上。


    //不存在引用类型的指针
   // int&* p2 = &y;
    //这是错误的，因为引用不是真实存在的，只是一个别名，而指针必须指向有实体的东西。
    //同理不存在引用的引用


    //当引用做函数的返回值：不要返回局部变量的引用，函数的调用可以作为左值。
    int& ref = test01();
    cout << ref << endl;
    test01() = 1000;
    cout << ref << endl;

    //const修饰的引用：
    const int& red = 10;
    //编译器会自动开辟一个变量空间，使他的值为10，在操作这个变量空间时只能使用引用名。
  //red = 20;//const修饰后是只读状太


	return 0;
}