//内存编号：从0开始的16进制数
//指针可以直接指向内存中的某个地址
//也可以说指针的值是某个变量的地址
#include<iostream>
using namespace std;
int main26() {

	int* m;
	
	//非指针变量的值本身并不是地址，因此无法直接起到指针的作用。
	// 指针可以存储和访问内存地址，而非指针变量只能存储和访问它们所代表的值。
	// 如果您想在不改变其值的情况下使用变量作为地址，您需要将其转换为指针。
	//简单来说非指针变量只是一个数。
	//c++规定：在32位操作系统下，指针类型都是占4个字节空间。
	//在64位系统中占8字节
	int a;
	
	m = &a;
	cin >> a;
	cout << "a的地址是 " << &a << endl;
	
	cout <<"指针m指向的地址是 " << m << endl;
	cout << "m指向地址的值是 " << *m << endl;
	
	cout << "指针所占的内存大小 " << sizeof(m) << endl;

	//当对指针进行操作时：
	*m = 20;
	cout << "此时a的值是： " << a<<endl;
	cout << "此时指针m指向的值是  " << *m<<endl;

	//另外指针在条件判断中：如果是零指针则是false，其他非零的指针则是true
	//如果使用undefined的指针则会出现编译错误。


	//特殊：void* 类型的指针可以指向任何类型的数据
	//但是void* 类型的指针只能用于存储变量的地址，不能访问变量。因为他没有指定数据类型

	void* p = NULL;

	p = m;
	//cout<<*p;  这是非法的。
	
	
	//如果要把void*类型指针的值赋值给另一个变量，要强制类型的转化

	int* n = (int*)p;
	//当m指向的对象发生变化时：
	int b = 30;
	m = &b;
	cout << "n指针指向的地址的值是 " << *n << endl;
	cout << "n指针指向的地址是 " << n<<endl;
	cout << "此时m的值是 " << *m<<endl;
	cout << "此时m指向的地址是 " << m<<endl;
	


	return 0;
}